<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aaron的博客</title>
  
  <subtitle>只想做一只安静的程序猿...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.520tech.cn/"/>
  <updated>2018-09-16T01:42:22.946Z</updated>
  <id>http://www.520tech.cn/</id>
  
  <author>
    <name>Aaron Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链</title>
    <link href="http://www.520tech.cn/2018/09/16/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://www.520tech.cn/2018/09/16/区块链/</id>
    <published>2018-09-16T01:42:22.946Z</published>
    <updated>2018-09-16T01:42:22.946Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://www.520tech.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="随笔" scheme="http://www.520tech.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>静心阅读</title>
    <link href="http://www.520tech.cn/2017/08/29/%E9%9D%99%E5%BF%83%E9%98%85%E8%AF%BB/"/>
    <id>http://www.520tech.cn/2017/08/29/静心阅读/</id>
    <published>2017-08-29T06:42:00.000Z</published>
    <updated>2018-09-16T01:42:22.946Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 静心阅读：</strong> <excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>欢迎大家来看我的技术博客，本人从事iOS开发。<br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="测试用的博客"><a href="#测试用的博客" class="headerlink" title="测试用的博客"></a>测试用的博客</h2></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 静心阅读：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="静心阅读" scheme="http://www.520tech.cn/categories/%E9%9D%99%E5%BF%83%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="随笔" scheme="http://www.520tech.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C底层原理（五）—— Category</title>
    <link href="http://www.520tech.cn/2017/01/05/OC-05-Category/"/>
    <id>http://www.520tech.cn/2017/01/05/OC-05-Category/</id>
    <published>2017-01-05T12:15:50.000Z</published>
    <updated>2018-09-16T01:42:22.945Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>Category的实现原理是什么？<br>Category和class extension有什么区别？<br>Category中的load和initialize方法怎么使用？<br>Category能否添加成员变量？<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我们平时写OC代码，写的基本也都得心应手。<br>比如创建一个对象，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br></pre></td></tr></table></figure><p>那么这个obj占用多少内存，内存又是如何分配的，对象又是如何产生的？</p><h2 id="Objective-C-类的本质"><a href="#Objective-C-类的本质" class="headerlink" title="Objective-C 类的本质"></a>Objective-C 类的本质</h2><p>OC代码的底层都是<code>C/C++</code> 实现的,所以OC的面向对象都是基于<code>C/C++</code>的数据结构来是实现的，那么现在思考一个问题，OC的类和对象是基于<code>C/C++</code>的什么<code>数据结构</code>实现的？</p><p>现在我们打开Xcode，创建一个Command line项目，我们在<code>main.m</code>文件中写入以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们找到<code>main.m</code>所在的文件目录，运行<code>Terminal</code>,并执行以下命令,将<code>main.m</code>文件重写成更底层的<code>C/C++</code>代码</p><h4 id="不指定架构重写"><a href="#不指定架构重写" class="headerlink" title="不指定架构重写"></a>不指定架构重写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>由于我们现在大都是在64位的平台进行开发，或者</p><h4 id="直接指定arm64架构重写"><a href="#直接指定arm64架构重写" class="headerlink" title="直接指定arm64架构重写"></a>直接指定arm64架构重写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>这样输出的文件会比不指定架构时要小很多。<br>这里我选择了指定<code>arm64</code>架构命令，执行完毕，我们会在原来的文件目录下看到<code>main.cpp</code>文件，打开这个文件，并在<code>7158行</code>找到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果我们不将代码转成<code>C/C++</code>底层的代码，我们直接通过代码跳转的方式去看NSObject的实现，我们会看到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似的结构，同样的的实例，它们都有且仅有一个<code>Class</code>类型的<code>isa</code>,这样我们可以从侧面证明，这个结构体就是我们要找的<code>NSObject</code>类的底层实现。通过这个一系列的操作，我们发现，<code>Objective-C</code>类的底层数据结构其实就是<code>C/C++</code>的结构体。</p><p>追根溯源，我们继续点击这个<code>Class</code>跳转到<code>Class</code>定义的地方。<br>我们能看到如下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p><p>原来<code>Class</code>是一个指向结构体的指针，那么这个对象占用多少内存呢？</p><h2 id="Objective-C-对象的本质"><a href="#Objective-C-对象的本质" class="headerlink" title="Objective-C 对象的本质"></a>Objective-C 对象的本质</h2><p>我们知道，一个指针在<code>64-bit</code>系统下占用8个字节的内存，但事实上系统为这个对象仅仅分配了8个字节的内存吗？我们用如下的代码来证实一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">        <span class="comment">//  获得NSObject类的实例对象的大小（runtime方法）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="comment">//  获得objc指针所指向的内存大小（malloc方法）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(objc)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行，这时我们看到输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-02 14:39:25.626472+0800 Main[26564:3507573] 8</span><br><span class="line">2018-09-02 14:39:25.627123+0800 Main[26564:3507573] 16</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p><p>一个输出8，一个输出16。也就是说NSObject类的实例对象的大小并不是objc对象所占用的内存大小，这到底是怎么回事呢？<br>基于Apple目前开源的源码，我们打开<a href="https://opensource.apple.com/tarballs/objc4" target="_blank" rel="noopener">苹果源码</a>，并下载<a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">objc4-723.tar.gz</a>解压后打开这个项目。</p><h4 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h4><p>我们直接全局搜索<code>class_getInstanceSize</code>，然后找到<code>objc-class.mm</code>文件中的对应的实现代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续查看<code>alignedInstanceSize()</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line"> uint32_t alignedInstanceSize() &#123;</span><br><span class="line">     <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里有一句注释，翻译成中文就是<code>类的实例对象的成员变量所占用的内存大小</code>，这个值就是<code>8</code>。</p><h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><p>我们继续全局搜索<code>allocWithZone</code>，然后找到<code>NSObject.mm</code>文件中定义的这个函数，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone)</span><br></pre></td></tr></table></figure></p><p>并且函数内部找到以下这句代码调用，<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = class_createInstance(cls, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>并跳转到<code>class_createInstance</code>函数的实现，我们可以看到如下的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">class_createInstance(Class cls, <span class="keyword">size_t</span> extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们继续跳转到<code>_class_createInstanceFromZone</code>函数的实现，在这个函数的实现内部，我们发现了有以下代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的obj在创建的时候，调用了一个<code>calloc</code>方法，并将<code>size</code>作为参数传了进去，这里的<code>size</code>哪里来的呢？我们跳转到<code>size</code>定义的地方，<code>size_t</code>类型的<code>size</code>变量通过如下代码创建的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t size = cls-&gt;instanceSize(extraBytes);</span><br></pre></td></tr></table></figure></p><p>我们再去看<code>instanceSize()</code>函数的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> instanceSize(<span class="keyword">size_t</span> extraBytes) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们又一次看到了<code>alignedInstanceSize()</code>这个函数，我们上面说过，<code>NSObject</code>对象在调用这个函数时，分配的内存的大小时8，而<code>extraBytes</code>的大小为0。所以这个size就是8；那么通过下面的代码，我们将初始化的对象分配了16个字节的大小。这行代码的意思就是，凡是内存小于16个字节的对象，全部强制分配给16个字节。</p><p>也就是说，这个对象在创建的时候，系统给其分配了16个字节的存储空间，但是其成员变量只占用了8个字节。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Category的实现原理是什么？&lt;br&gt;Category和class extension有什么区别？&lt;br&gt;Category中的load和initialize方法怎么使用？&lt;br&gt;Category能否添加成员变量？&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://www.520tech.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://www.520tech.cn/tags/Objective-C/"/>
    
      <category term="底层原理" scheme="http://www.520tech.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C底层原理（四）—— KVC</title>
    <link href="http://www.520tech.cn/2017/01/04/OC-04-KVC/"/>
    <id>http://www.520tech.cn/2017/01/04/OC-04-KVC/</id>
    <published>2017-01-03T17:50:56.000Z</published>
    <updated>2018-09-16T01:42:22.945Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>什么是KVC？<br>KVC底层是如何实现的？<br>通过KVC修改属性会不会触发KVO？<br>KVC的API实现的原理是什么？<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我们平时写OC代码，写的基本也都得心应手。<br>比如创建一个对象，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br></pre></td></tr></table></figure><p>那么这个obj占用多少内存，内存又是如何分配的，对象又是如何产生的？</p><h2 id="Objective-C-类的本质"><a href="#Objective-C-类的本质" class="headerlink" title="Objective-C 类的本质"></a>Objective-C 类的本质</h2><p>OC代码的底层都是<code>C/C++</code> 实现的,所以OC的面向对象都是基于<code>C/C++</code>的数据结构来是实现的，那么现在思考一个问题，OC的类和对象是基于<code>C/C++</code>的什么<code>数据结构</code>实现的？</p><p>现在我们打开Xcode，创建一个Command line项目，我们在<code>main.m</code>文件中写入以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们找到<code>main.m</code>所在的文件目录，运行<code>Terminal</code>,并执行以下命令,将<code>main.m</code>文件重写成更底层的<code>C/C++</code>代码</p><h4 id="不指定架构重写"><a href="#不指定架构重写" class="headerlink" title="不指定架构重写"></a>不指定架构重写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>由于我们现在大都是在64位的平台进行开发，或者</p><h4 id="直接指定arm64架构重写"><a href="#直接指定arm64架构重写" class="headerlink" title="直接指定arm64架构重写"></a>直接指定arm64架构重写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>这样输出的文件会比不指定架构时要小很多。<br>这里我选择了指定<code>arm64</code>架构命令，执行完毕，我们会在原来的文件目录下看到<code>main.cpp</code>文件，打开这个文件，并在<code>7158行</code>找到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果我们不将代码转成<code>C/C++</code>底层的代码，我们直接通过代码跳转的方式去看NSObject的实现，我们会看到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似的结构，同样的的实例，它们都有且仅有一个<code>Class</code>类型的<code>isa</code>,这样我们可以从侧面证明，这个结构体就是我们要找的<code>NSObject</code>类的底层实现。通过这个一系列的操作，我们发现，<code>Objective-C</code>类的底层数据结构其实就是<code>C/C++</code>的结构体。</p><p>追根溯源，我们继续点击这个<code>Class</code>跳转到<code>Class</code>定义的地方。<br>我们能看到如下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p><p>原来<code>Class</code>是一个指向结构体的指针，那么这个对象占用多少内存呢？</p><h2 id="Objective-C-对象的本质"><a href="#Objective-C-对象的本质" class="headerlink" title="Objective-C 对象的本质"></a>Objective-C 对象的本质</h2><p>我们知道，一个指针在<code>64-bit</code>系统下占用8个字节的内存，但事实上系统为这个对象仅仅分配了8个字节的内存吗？我们用如下的代码来证实一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">        <span class="comment">//  获得NSObject类的实例对象的大小（runtime方法）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="comment">//  获得objc指针所指向的内存大小（malloc方法）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(objc)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行，这时我们看到输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-02 14:39:25.626472+0800 Main[26564:3507573] 8</span><br><span class="line">2018-09-02 14:39:25.627123+0800 Main[26564:3507573] 16</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p><p>一个输出8，一个输出16。也就是说NSObject类的实例对象的大小并不是objc对象所占用的内存大小，这到底是怎么回事呢？<br>基于Apple目前开源的源码，我们打开<a href="https://opensource.apple.com/tarballs/objc4" target="_blank" rel="noopener">苹果源码</a>，并下载<a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">objc4-723.tar.gz</a>解压后打开这个项目。</p><h4 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h4><p>我们直接全局搜索<code>class_getInstanceSize</code>，然后找到<code>objc-class.mm</code>文件中的对应的实现代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续查看<code>alignedInstanceSize()</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line"> uint32_t alignedInstanceSize() &#123;</span><br><span class="line">     <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里有一句注释，翻译成中文就是<code>类的实例对象的成员变量所占用的内存大小</code>，这个值就是<code>8</code>。</p><h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><p>我们继续全局搜索<code>allocWithZone</code>，然后找到<code>NSObject.mm</code>文件中定义的这个函数，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone)</span><br></pre></td></tr></table></figure></p><p>并且函数内部找到以下这句代码调用，<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = class_createInstance(cls, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>并跳转到<code>class_createInstance</code>函数的实现，我们可以看到如下的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">class_createInstance(Class cls, <span class="keyword">size_t</span> extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们继续跳转到<code>_class_createInstanceFromZone</code>函数的实现，在这个函数的实现内部，我们发现了有以下代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的obj在创建的时候，调用了一个<code>calloc</code>方法，并将<code>size</code>作为参数传了进去，这里的<code>size</code>哪里来的呢？我们跳转到<code>size</code>定义的地方，<code>size_t</code>类型的<code>size</code>变量通过如下代码创建的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t size = cls-&gt;instanceSize(extraBytes);</span><br></pre></td></tr></table></figure></p><p>我们再去看<code>instanceSize()</code>函数的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> instanceSize(<span class="keyword">size_t</span> extraBytes) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们又一次看到了<code>alignedInstanceSize()</code>这个函数，我们上面说过，<code>NSObject</code>对象在调用这个函数时，分配的内存的大小时8，而<code>extraBytes</code>的大小为0。所以这个size就是8；那么通过下面的代码，我们将初始化的对象分配了16个字节的大小。这行代码的意思就是，凡是内存小于16个字节的对象，全部强制分配给16个字节。</p><p>也就是说，这个对象在创建的时候，系统给其分配了16个字节的存储空间，但是其成员变量只占用了8个字节。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;什么是KVC？&lt;br&gt;KVC底层是如何实现的？&lt;br&gt;通过KVC修改属性会不会触发KVO？&lt;br&gt;KVC的API实现的原理是什么？&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://www.520tech.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://www.520tech.cn/tags/Objective-C/"/>
    
      <category term="底层原理" scheme="http://www.520tech.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C底层原理（三）—— KVO</title>
    <link href="http://www.520tech.cn/2017/01/03/OC-03-KVO/"/>
    <id>http://www.520tech.cn/2017/01/03/OC-03-KVO/</id>
    <published>2017-01-03T12:45:00.000Z</published>
    <updated>2018-09-16T01:42:22.944Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>    KVO底层是如何实现的？<br>    如何手动触发KVO？<br>    被KVO监听了的对象发生了什么变化？<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>KVO，又被成为键值监听，即被监听的键的值发生改变时，做出一系列的响应。</p><h2 id="KVO代码"><a href="#KVO代码" class="headerlink" title="KVO代码"></a>KVO代码</h2></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;    KVO底层是如何实现的？&lt;br&gt;    如何手动触发KVO？&lt;br&gt;    被KVO监听了的对象发生了什么变化？&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://www.520tech.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://www.520tech.cn/tags/Objective-C/"/>
    
      <category term="底层原理" scheme="http://www.520tech.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C底层原理（二）—— OC对象的种类</title>
    <link href="http://www.520tech.cn/2017/01/02/OC-02-OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A7%8D%E7%B1%BB/"/>
    <id>http://www.520tech.cn/2017/01/02/OC-02-OC对象的种类/</id>
    <published>2017-01-02T12:35:50.000Z</published>
    <updated>2018-09-16T01:42:22.944Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>Objective-C中的对象共可以分为三种：<br>    instance对象（实例对象）<br>    class对象（类对象）<br>    meta-class对象（元类对象）<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="instance对象"><a href="#instance对象" class="headerlink" title="instance对象"></a>instance对象</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>通过类<code>alloc</code>出来的对象，每次调用<code>alloc</code>方法都会产生新的instance对象。</p><h3 id="对象内存中存储的信息："><a href="#对象内存中存储的信息：" class="headerlink" title="对象内存中存储的信息："></a>对象内存中存储的信息：</h3><p><code>instance</code>对象在内存中存储的信息包括：</p><ol><li><code>isa</code>指针</li><li>其它的成员变量</li></ol><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>先看一组OC代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">Class obj1 = [objc <span class="keyword">class</span>];</span><br><span class="line">Class obj2 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line">Class obj3 = object_getClass(objc);</span><br></pre></td></tr></table></figure></p><p>其中obj1、obj2、obj3它们都是<code>Class</code>类型的对象<br>，都是<code>NSObject</code>的类对象。</p><h3 id="对象内存中存储的信息：-1"><a href="#对象内存中存储的信息：-1" class="headerlink" title="对象内存中存储的信息："></a>对象内存中存储的信息：</h3><p>class对象在内存中存储的信息主要包括：</p><ol><li><code>isa</code>指针；</li><li><code>superClass</code>指针；</li><li>类的属性信息(<code>property</code>)；</li><li>类的对象方法信息(<code>instance method</code>)；</li><li>类的协议信息(<code>protocol</code>)；</li><li>类的成员变量信息(<code>ivar</code>)；<ul><li>注意：这里不包含类方法信息(<code>class method</code>)，那么类方法存在了什么地方呢？</li></ul></li></ol><h2 id="meta-class对象"><a href="#meta-class对象" class="headerlink" title="meta-class对象"></a>meta-class对象</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>什么是元类对象？我们看下面一行代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class metaClassObj = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure></p><p><code>metaClassObj</code>是我们通过运行时获取的<code>NSObject</code>类对象的类对象，其本质上依然是一个类对象。那么这个<code>metaClassObj</code>就是<code>NSObject</code>的元类对象(<code>meta-class</code>)，并且每个类在内存中有且只有一个元类对象。</p><h3 id="对象内存中存储的信息：-2"><a href="#对象内存中存储的信息：-2" class="headerlink" title="对象内存中存储的信息："></a>对象内存中存储的信息：</h3><p><code>meta-class</code>和<code>Class</code>的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括：</p><ol><li><code>isa</code>指针</li><li><code>superclass</code>指针</li><li>类的类方法信息(<code>class method</code>)</li><li>…</li></ol><h2 id="比较获取类对象的方法"><a href="#比较获取类对象的方法" class="headerlink" title="比较获取类对象的方法"></a>比较获取类对象的方法</h2><h5 id="Class-objc-getClass-const-char-aClassName"><a href="#Class-objc-getClass-const-char-aClassName" class="headerlink" title="Class objc_getClass(const char *aClassName)"></a><code>Class objc_getClass(const char *aClassName)</code></h5><p> 1&gt; 传入字符串类名<br> 2&gt; 返回对应的类对象</p><h5 id="Class-object-getClass-id-obj"><a href="#Class-object-getClass-id-obj" class="headerlink" title="Class object_getClass(id obj)"></a><code>Class object_getClass(id obj)</code></h5><p> 1&gt; 传入的obj可能是instance对象、class对象、meta-class对象<br> 2&gt; 返回值<br> a) 如果是instance对象，返回class对象<br> b) 如果是class对象，返回meta-class对象<br> c) 如果是meta-class对象，返回NSObject（基类）的meta-class对象</p><h5 id="Class-class、-Class-class"><a href="#Class-class、-Class-class" class="headerlink" title="- (Class)class、+ (Class)class"></a><code>- (Class)class、+ (Class)class</code></h5><p>返回值就是类对象<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种对象之间的关系（方法调用原理）"><a href="#三种对象之间的关系（方法调用原理）" class="headerlink" title="三种对象之间的关系（方法调用原理）"></a>三种对象之间的关系（方法调用原理）</h2><p>instance的isa指向class</p><p>class的isa指向meta-class</p><p>meta-class的isa指向基类的meta-class</p><p>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</p><p>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</p><p>instance调用对象方法的轨迹<br>isa找到class，方法不存在，就通过superclass找父类</p><p>class调用类方法的轨迹<br>isa找meta-class，方法不存在，就通过superclass找父类</p><p>如下图所示：<br><img src="http://peqakd06c.bkt.clouddn.com/15364882268573.jpg" alt=""></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Objective-C中的对象共可以分为三种：&lt;br&gt;    instance对象（实例对象）&lt;br&gt;    class对象（类对象）&lt;br&gt;    meta-class对象（元类对象）&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://www.520tech.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://www.520tech.cn/tags/Objective-C/"/>
    
      <category term="底层原理" scheme="http://www.520tech.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C底层原理（一）—— 类和实例对象的本质</title>
    <link href="http://www.520tech.cn/2017/01/01/OC-01-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.520tech.cn/2017/01/01/OC-01-类和对象/</id>
    <published>2017-01-01T13:55:00.000Z</published>
    <updated>2018-09-16T01:42:22.943Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>一个NSObject对象占用多少内存？<br>创建一个实例对象至少要分配多少内存？<br>对象的isa指针指向哪里？<br>内存又是如何分配的，对象又是如何产生的？<br>OC对象分为几类？<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我们平时写OC代码，写的基本也都得心应手。<br>比如创建一个对象，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br></pre></td></tr></table></figure><p>那么这个obj占用多少内存，内存又是如何分配的，对象又是如何产生的？</p><h2 id="Objective-C-类的本质"><a href="#Objective-C-类的本质" class="headerlink" title="Objective-C 类的本质"></a>Objective-C 类的本质</h2><p>OC代码的底层都是<code>C/C++</code> 实现的,所以OC的面向对象都是基于<code>C/C++</code>的数据结构来是实现的，那么现在思考一个问题，OC的类和对象是基于<code>C/C++</code>的什么<code>数据结构</code>实现的？</p><p>现在我们打开Xcode，创建一个Command line项目，我们在<code>main.m</code>文件中写入以下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们找到<code>main.m</code>所在的文件目录，运行<code>Terminal</code>,并执行以下命令,将<code>main.m</code>文件重写成更底层的<code>C/C++</code>代码</p><h4 id="不指定架构重写"><a href="#不指定架构重写" class="headerlink" title="不指定架构重写"></a>不指定架构重写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>由于我们现在大都是在64位的平台进行开发，或者</p><h4 id="直接指定arm64架构重写"><a href="#直接指定arm64架构重写" class="headerlink" title="直接指定arm64架构重写"></a>直接指定arm64架构重写</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>这样输出的文件会比不指定架构时要小很多。<br>这里我选择了指定<code>arm64</code>架构命令，执行完毕，我们会在原来的文件目录下看到<code>main.cpp</code>文件，打开这个文件，并在<code>7158行</code>找到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果我们不将代码转成<code>C/C++</code>底层的代码，我们直接通过代码跳转的方式去看NSObject的实现，我们会看到如下代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似的结构，同样的的实例，它们都有且仅有一个<code>Class</code>类型的<code>isa</code>,这样我们可以从侧面证明，这个结构体就是我们要找的<code>NSObject</code>类的底层实现。通过这个一系列的操作，我们发现，<code>Objective-C</code>类的底层数据结构其实就是<code>C/C++</code>的结构体。</p><p>追根溯源，我们继续点击这个<code>Class</code>跳转到<code>Class</code>定义的地方。<br>我们能看到如下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p><p>原来<code>Class</code>是一个指向结构体的指针，那么这个对象占用多少内存呢？</p><h2 id="Objective-C-对象的本质"><a href="#Objective-C-对象的本质" class="headerlink" title="Objective-C 对象的本质"></a>Objective-C 对象的本质</h2><p>我们知道，一个指针在<code>64-bit</code>系统下占用8个字节的内存，但事实上系统为这个对象仅仅分配了8个字节的内存吗？我们用如下的代码来证实一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">        <span class="comment">//  获得NSObject类的实例对象的大小（runtime方法）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="comment">//  获得objc指针所指向的内存大小（malloc方法）</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(objc)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行，这时我们看到输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-02 14:39:25.626472+0800 Main[26564:3507573] 8</span><br><span class="line">2018-09-02 14:39:25.627123+0800 Main[26564:3507573] 16</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p><p>一个输出8，一个输出16。也就是说NSObject类的实例对象的大小并不是objc对象所占用的内存大小，这到底是怎么回事呢？<br>基于Apple目前开源的源码，我们打开<a href="https://opensource.apple.com/tarballs/objc4" target="_blank" rel="noopener">苹果源码</a>，并下载<a href="https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz" target="_blank" rel="noopener">objc4-723.tar.gz</a>解压后打开这个项目。</p><h4 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h4><p>我们直接全局搜索<code>class_getInstanceSize</code>，然后找到<code>objc-class.mm</code>文件中的对应的实现代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续查看<code>alignedInstanceSize()</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line"> uint32_t alignedInstanceSize() &#123;</span><br><span class="line">     <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里有一句注释，翻译成中文就是<code>类的实例对象的成员变量所占用的内存大小</code>，这个值就是<code>8</code>。</p><h4 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h4><p>我们继续全局搜索<code>allocWithZone</code>，然后找到<code>NSObject.mm</code>文件中定义的这个函数，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone)</span><br></pre></td></tr></table></figure></p><p>并且函数内部找到以下这句代码调用，<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = class_createInstance(cls, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>并跳转到<code>class_createInstance</code>函数的实现，我们可以看到如下的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">class_createInstance(Class cls, <span class="keyword">size_t</span> extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们继续跳转到<code>_class_createInstanceFromZone</code>函数的实现，在这个函数的实现内部，我们发现了有以下代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的obj在创建的时候，调用了一个<code>calloc</code>方法，并将<code>size</code>作为参数传了进去，这里的<code>size</code>哪里来的呢？我们跳转到<code>size</code>定义的地方，<code>size_t</code>类型的<code>size</code>变量通过如下代码创建的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t size = cls-&gt;instanceSize(extraBytes);</span><br></pre></td></tr></table></figure></p><p>我们再去看<code>instanceSize()</code>函数的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> instanceSize(<span class="keyword">size_t</span> extraBytes) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们又一次看到了<code>alignedInstanceSize()</code>这个函数，我们上面说过，<code>NSObject</code>对象在调用这个函数时，分配的内存的大小时8，而<code>extraBytes</code>的大小为0。所以这个size就是8；那么通过下面的代码，我们将初始化的对象分配了16个字节的大小。这行代码的意思就是，凡是内存小于16个字节的对象，全部强制分配给16个字节。</p><p>也就是说，这个对象在创建的时候，系统给其分配了16个字节的存储空间，但是其成员变量只占用了8个字节。</p><p>现在再提出一个问题，看以下代码，创建一个<code>Student</code>的类的实例，问这个实例，系统分配多少内存？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">int</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Student *stu = [[Student alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样用指定<code>arm64</code>架构的方式对文件进行重写，然后找到<code>Student</code>类对应的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line"><span class="keyword">int</span> _age;</span><br><span class="line"><span class="keyword">int</span> _height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>并且找到<code>NSObject_IMPL</code>定义的地方<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其实相当于这个<code>Student</code>类的底层实现是这个样子的:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">   Class isa; <span class="comment">// 8个字节</span></span><br><span class="line"><span class="keyword">int</span> _age; <span class="comment">// 4个字节</span></span><br><span class="line"><span class="keyword">int</span> _height; <span class="comment">// 4个字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中<code>_age</code>和<code>_height</code>都是占用四个字节的内存，这样，<code>Student_IMPL</code>这个结构体就会占用16个字节的内存。可以使用<code>malloc_size()</code>函数来证实一下。<br>其实这里也用到一个<code>内存对齐</code>的一个概念，意思就是说结构体内成员按自身按自身长度自对齐，结构体的大小必须是最大成员大小的倍数，在这个结构体中，成员大小最小是16个字节，那么16其大小也必须是16的倍数。事实上，系统给这个结构体也只分配了16个字节的存储空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、OC中类的本质其实就是一个结构体<br>2、指定<code>arm64</code>架构重写OC文件的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure></p><p>3、一个<code>NSObject</code>对象占用8个字节的存储空间，但是系统会为该对象分配16个字节的存储空间<br>4、内存对齐</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;一个NSObject对象占用多少内存？&lt;br&gt;创建一个实例对象至少要分配多少内存？&lt;br&gt;对象的isa指针指向哪里？&lt;br&gt;内存又是如何分配的，对象又是如何产生的？&lt;br&gt;OC对象分为几类？&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://www.520tech.cn/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://www.520tech.cn/tags/Objective-C/"/>
    
      <category term="底层原理" scheme="http://www.520tech.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法和 MWeb 写作使用说明</title>
    <link href="http://www.520tech.cn/2016/02/02/tool-02-%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.520tech.cn/2016/02/02/tool-02-使用插件写博客/</id>
    <published>2016-02-02T04:06:00.000Z</published>
    <updated>2018-09-16T01:42:22.946Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>Markdown 的目標是實現「易讀易寫」。<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h1 id="Markdown-语法和-MWeb-写作使用说明"><a href="#Markdown-语法和-MWeb-写作使用说明" class="headerlink" title="Markdown 语法和 MWeb 写作使用说明"></a>Markdown 语法和 MWeb 写作使用说明</h1><h2 id="Markdown-的设计哲学"><a href="#Markdown-的设计哲学" class="headerlink" title="Markdown 的设计哲学"></a>Markdown 的设计哲学</h2><blockquote><p>Markdown 的目標是實現「易讀易寫」。<br>不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。<br>Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。</p></blockquote><!-- more --><h2 id="本文约定"><a href="#本文约定" class="headerlink" title="本文约定"></a>本文约定</h2><p>如果有写 <code>效果如下：</code>， 在 MWeb 编辑状态下只有用 <code>CMD + R</code> 预览才可以看效果。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 第一级标题 `&lt;h1&gt;` </span><br><span class="line">## 第二级标题 `&lt;h2&gt;` </span><br><span class="line">###### 第六级标题 `&lt;h6&gt;`</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="第一级标题-lt-h1-gt"><a href="#第一级标题-lt-h1-gt" class="headerlink" title="第一级标题 &lt;h1&gt;"></a>第一级标题 <code>&lt;h1&gt;</code></h1><h2 id="第二级标题-lt-h2-gt"><a href="#第二级标题-lt-h2-gt" class="headerlink" title="第二级标题 &lt;h2&gt;"></a>第二级标题 <code>&lt;h2&gt;</code></h2><h6 id="第六级标题-lt-h6-gt"><a href="#第六级标题-lt-h6-gt" class="headerlink" title="第六级标题 &lt;h6&gt;"></a>第六级标题 <code>&lt;h6&gt;</code></h6><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*这些文字会生成`&lt;em&gt;`*</span><br><span class="line">_这些文字会生成`&lt;u&gt;`_</span><br><span class="line"></span><br><span class="line">**这些文字会生成`&lt;strong&gt;`**</span><br><span class="line">__这些文字会生成`&lt;strong&gt;`__</span><br></pre></td></tr></table></figure><p>在 MWeb 中的快捷键为： <code>CMD + U</code>、<code>CMD + I</code>、<code>CMD + B</code><br>效果如下：</p><p><em>这些文字会生成<code>&lt;em&gt;</code></em><br><em>这些文字会生成<code>&lt;u&gt;</code></em></p><p><strong>这些文字会生成<code>&lt;strong&gt;</code></strong><br><strong>这些文字会生成<code>&lt;strong&gt;</code></strong></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>四个及以上空格加回车。<br>如果不想打这么多空格，只要回车就为换行，请勾选：<code>Preferences</code> - <code>Themes</code> - <code>Translate newlines to &lt;br&gt; tags</code></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 项目一 无序列表 `* + 空格键`</span><br><span class="line">* 项目二</span><br><span class="line">* 项目二的子项目一 无序列表 `* + TAB + 空格键`</span><br><span class="line">* 项目二的子项目二</span><br></pre></td></tr></table></figure><p>在 MWeb 中的快捷键为： <code>Option + U</code><br>效果如下：</p><ul><li>项目一 无序列表 <code>* + 空格键</code></li><li>项目二<ul><li>项目二的子项目一 无序列表 <code>* + TAB + 空格键</code></li><li>项目二的子项目二</li></ul></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 项目一 有序列表 `数字 + . + 空格键`</span><br><span class="line">2. 项目二 </span><br><span class="line">3. 项目三</span><br><span class="line">1. 项目三的子项目一 有序列表 `数字 + . + TAB + 空格键`</span><br><span class="line">2. 项目三的子项目二</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>项目一 有序列表 <code>数字 + . + 空格键</code></li><li>项目二 </li><li>项目三<ol><li>项目三的子项目一 有序列表 <code>数字 + . + TAB + 空格键</code></li><li>项目三的子项目二</li></ol></li></ol><h3 id="任务列表（Task-lists）"><a href="#任务列表（Task-lists）" class="headerlink" title="任务列表（Task lists）"></a>任务列表（Task lists）</h3><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 任务一 未做任务 `- + 空格 + [ ]`</span><br><span class="line">- [x] 任务二 已做任务 `- + 空格 + [x]`</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li style="list-style: none"><input type="checkbox"> 任务一 未做任务 <code>- + 空格 + [ ]</code></li><li style="list-style: none"><input type="checkbox" checked> 任务二 已做任务 <code>- + 空格 + [x]</code></li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)</span><br><span class="line">格式: ![Alt Text](url)</span><br></pre></td></tr></table></figure><p><code>Control + Shift + I</code> 可插入Markdown语法。<br>如果是 MWeb 的文档库中的文档，还可以用拖放图片、<code>CMD + V</code> 粘贴、<code>CMD + Option + I</code> 导入这三种方式来增加图片。<br>效果如下：</p><p><img src="http://zh.mweb.im/asset/img/set-up-git.gif" alt="GitHub set up"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">email &lt;example@example.com&gt;</span><br><span class="line">[GitHub](http://github.com)</span><br><span class="line">自动生成连接  &lt;http://www.github.com/&gt;</span><br></pre></td></tr></table></figure><p><code>Control + Shift + L</code> 可插入Markdown语法。<br>如果是 MWeb 的文档库中的文档，拖放或<code>CMD + Option + I</code> 导入非图片时，会生成连接。<br>效果如下：</p><p>Email 连接： <a href="mailto:&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a><br><a href="http://github.com" target="_blank" rel="noopener">连接标题Github网站</a><br>自动生成连接像： <a href="http://www.github.com/" target="_blank" rel="noopener">http://www.github.com/</a> 这样</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">某某说:</span><br><span class="line">&gt; 第一行引用</span><br><span class="line">&gt; 第二行费用文字</span><br></pre></td></tr></table></figure><p><code>CMD + Shift + B</code> 可插入Markdown语法。<br>效果如下：</p><p>某某说:</p><blockquote><p>第一行引用<br>第二行费用文字</p></blockquote><h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">像这样即可：`&lt;addr&gt;` `code`</span><br></pre></td></tr></table></figure><p><code>CMD + K</code> 可插入Markdown语法。<br>效果如下：</p><p>像这样即可：<code>&lt;addr&gt;</code> <code>code</code></p><h2 id="多行或者一段代码"><a href="#多行或者一段代码" class="headerlink" title="多行或者一段代码"></a>多行或者一段代码</h2><p>Markdown 语法：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fancyAlert</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arg) &#123;</span><br><span class="line">    $.facebox(&#123;<span class="attr">div</span>:<span class="string">'#foo'</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><code>CMD + Shift + K</code> 可插入Markdown语法。<br>效果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fancyAlert</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arg) &#123;</span><br><span class="line">$.facebox(&#123;<span class="attr">div</span>:<span class="string">'#foo'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序图或流程图"><a href="#顺序图或流程图" class="headerlink" title="顺序图或流程图"></a>顺序图或流程图</h2><p>Markdown 语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></code></pre><p>效果如下（ <code>Preferences</code> - <code>Themes</code> - <code>Enable sequence &amp; flow chart</code> 才会看到效果 ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>更多请参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">http://bramp.github.io/js-sequence-diagrams/</a>, <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">http://adrai.github.io/flowchart.js/</a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一格表头 | 第二格表头</span><br><span class="line">--------- | -------------</span><br><span class="line">内容单元格 第一列第一格 | 内容单元格第二列第一格</span><br><span class="line">内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>第一格表头</th><th>第二格表头</th></tr></thead><tbody><tr><td>内容单元格 第一列第一格</td><td>内容单元格第二列第一格</td></tr><tr><td>内容单元格 第一列第二格 多加文字</td><td>内容单元格第二列第二格</td></tr></tbody></table><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>Markdown 语法：</p><pre><code>加删除线像这样用： ~~删除这些~~</code></pre><p>效果如下：</p><p>加删除线像这样用： <del>删除这些</del></p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>以下三种方式都可以生成分隔线：</p><pre><code>********- - -</code></pre><p>效果如下：</p><hr><hr><hr><h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">块级公式：</span><br><span class="line">$$x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br><span class="line"></span><br><span class="line">\\[ \frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =</span><br><span class="line">1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125; \\]</span><br><span class="line"></span><br><span class="line">行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$</span><br></pre></td></tr></table></figure><p>效果如下（<code>Preferences</code> - <code>Themes</code> - <code>Enable MathJax</code> 才会看到效果）：</p><p>块级公式：<br>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =<br>1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}<br>{1+\frac{e^{-8\pi}} {1+\ldots} } } } \]</p><p>行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$</p><h2 id="脚注（Footnote）"><a href="#脚注（Footnote）" class="headerlink" title="脚注（Footnote）"></a>脚注（Footnote）</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个脚注：[^sample_footnote]</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>这是一个脚注：<a href="这里是脚注信息">^sample_footnote</a></p><h2 id="注释和阅读更多"><a href="#注释和阅读更多" class="headerlink" title="注释和阅读更多"></a>注释和阅读更多</h2><!-- comment --><!-- more --><p>Actions-&gt;Insert Read More Comment <em>或者</em> <code>Command + .</code><br><strong>注</strong> 阅读更多的功能只用在生成网站或博客时。</p><h2 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h2><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>[TOC]</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Markdown 的目標是實現「易讀易寫」。&lt;br&gt;
    
    </summary>
    
      <category term="实用工具" scheme="http://www.520tech.cn/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="http://www.520tech.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>MWeb介绍</title>
    <link href="http://www.520tech.cn/2016/02/01/tool-01-MWeb%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.520tech.cn/2016/02/01/tool-01-MWeb介绍/</id>
    <published>2016-02-01T04:06:00.000Z</published>
    <updated>2018-09-16T01:42:22.946Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>MWeb简介<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h1 id="MWeb-专业的-Markdown-写作、记笔记、静态博客生成软件"><a href="#MWeb-专业的-Markdown-写作、记笔记、静态博客生成软件" class="headerlink" title="MWeb - 专业的 Markdown 写作、记笔记、静态博客生成软件"></a>MWeb - 专业的 Markdown 写作、记笔记、静态博客生成软件</h1><h2 id="专业的-Markdown-写作支持"><a href="#专业的-Markdown-写作支持" class="headerlink" title="专业的 Markdown 写作支持"></a>专业的 Markdown 写作支持</h2><ul><li>极简 UI、Dark Mode、漂亮的 Markdown 语法高亮、列表缩进优化，提供 5 种主题选择。</li><li>除了支持基本的 Markdown 语法外，还支持大量 Markdown 扩展语法：Table、TOC、MathJax、Fenced code block、任务列表（Task lists）、顺序图和流程图、Footnote 等。</li><li>支持 Typewriter Scrolling（打机滚动模式）<code>View</code> - <code>Typewriter Scrolling</code>。</li><li>支持发布和<strong>更新</strong>到：Wordrpess 博客、支持 Metaweblog API 的博客服务、Wordpress.com、Evernote 和印象笔记、Blogger、Tumblr。请在 <code>Preferences</code> - <code>Publishing</code> 增加发布服务，然后点击软件右上角的分享按钮即可看到所增加的发布服务。</li><li>支持即时预览并提供 6 种预览主题，其中二种和静态博客主题相对应，也就是说您在写博客时可以即时预览大概效果！所有主题效果都支持导出为 HTML、PDF。快捷键 <code>CMD + R</code> 或 <code>CMD + 4</code> 打开即时预览窗口。</li><li>编辑器和实时预览都支持大纲视图，长文档时跳转非常方便。</li></ul><h2 id="设计为两种模式"><a href="#设计为两种模式" class="headerlink" title="设计为两种模式"></a>设计为两种模式</h2><ul><li>外部文档模式：用于新建、打开和编辑外部 Markdown 文档。也支持引入外部文件夹到 MWeb 中管理。</li><li>文档库模式：用分类树管理文档，可以把文档设为多个分类，用于记笔记和静态网站生成。</li></ul><p><code>CMD + E</code> 或使用菜单 <code>View</code> - <code>Open External</code> 可打开外部文档模式。</p><p><code>CMD + L</code> 或使用菜单 <code>View</code> - <code>Open Library</code> 可打开文档库。</p><p>文档库模式和外部模式都支持<strong>全文搜寻（Full Text Search）</strong>，都可以用拖放或粘贴插入图片并直接显示。<code>CMD + V</code> 粘贴为JPG格式，<code>CMD + Shift + V</code> 粘贴为PNG透明格式。</p><p>外部模式引入 Octpress、Jekyll 等静态博客的文件夹后也支持拖放或粘贴插入图片和实时预览，详细请参考：<a href="http://zh.mweb.im/mweb-1.4-add-floder-octpress-support.html" target="_blank" rel="noopener">引入文件夹到 MWeb 中管理，支持 Octpress、Jekyll 等静态博客拖拽插入图片和实时预览</a></p><h2 id="文档库模式用于记笔记"><a href="#文档库模式用于记笔记" class="headerlink" title="文档库模式用于记笔记"></a>文档库模式用于记笔记</h2><p>文档库模式使用分类树组织和管理文档，支持拖放或粘贴插入图片并直接显示，插入非图片则会生成连结。<br>支持把 Markdown 或文本文档导入到文档库，也支持把整个分类或者文档（可选多个）导出为 HTML、PDF、Markdown。</p><p>更详细的信息请看：<a href="http://zh.mweb.im/mweb-document-library.html" target="_blank" rel="noopener">MWeb 文档库模式详细说明</a></p><h2 id="文档库模式用于静态博客生成"><a href="#文档库模式用于静态博客生成" class="headerlink" title="文档库模式用于静态博客生成"></a>文档库模式用于静态博客生成</h2><p>一键把分类生成静态博客，目前可选二个主题，支持自定主题。只要填入 Disqus、多说提供的代码即可以为博客增加评论功能。可勾选让网站支持 MathJax 和顺序图、流程图。</p><p>更详细的信息请看：<a href="http://zh.mweb.im/mweb-static-blog-generator.html" target="_blank" rel="noopener">MWeb 生成静态博客详细说明</a>、<a href="http://zh.mweb.im/mweb-1.4-static-blog-extension.html" target="_blank" rel="noopener">静态博客功能增强</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;MWeb简介&lt;br&gt;
    
    </summary>
    
      <category term="实用工具" scheme="http://www.520tech.cn/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="http://www.520tech.cn/tags/Markdown/"/>
    
  </entry>
  
</feed>
