[{"title":"区块链","url":"%2F2018%2F09%2F16%2F%E5%8C%BA%E5%9D%97%E9%93%BE%2F","content":"<Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n","tags":["随笔"],"categories":["区块链"]},{"title":"iOS性能优化（一）—— 卡顿优化","url":"%2F2017%2F04%2F01%2FiOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-01-%E5%8D%A1%E9%A1%BF%2F","content":"\n\\<Excerpt in index | 首页摘要\\>\n性能优化从哪些方面着手？\n什么是CPU，什么是GPU？\n列表卡顿的原因可能有哪些？你平时是怎么优化的？\n遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？\n<!-- more -->\n\\<The rest of contents | 余下全文\\>\n\n# CPU和GPU\n在屏幕成像的过程中，CPU和GPU起着至关重要的作用。\n* `CPU`——（`Central Processing Unit`，中央处理器）主要负责对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（`Core Graphics`）。\n\n* `GPU`——（`Graphics Processing Unit`，图形处理器）主要负责纹理的渲染。\nAPP的显示一般是由`CPU`和`GPU`协同处理的。\n`CPU`负责数据的计算，然后将计算好的数据提交给`GPU`，`GPU`会将这些计算好的数据进行`渲染`，`GPU`将渲染好的数据存放在`帧缓存`里面；接着，`视频控制器`会去读取`帧缓存`里面的数据，然后将读取出来的数据完整地显示在`屏幕`上。这样就完成了数据的显示。\n\n*注意：在iOS中是双缓冲机制，有前帧缓存、后帧缓存。* \n\n# 卡顿产生的原因及优化思路\n\n* 我们看到的手机APP能够完成一些列的动态显示，其实是由`垂直同步信号（VSync）`和`水平同步信号（HSync）`协作完成。`VSync`先发出，随后`HSync`发出，完成整屏画面的显示；紧接着，再次发出一个`VSync`，显示下一帧的画面。\n\n* 一旦发生了一个`VSync`，`GPU`会立马将缓存里面的数据渲染到屏幕上，完成画面显示。如果`GPU`处理的时间过长，导致`VSync`已经发出，而`GPU`还没有处理完，这时只能显示上一帧的`VSync`，而当前帧的`VSync`就丢失了，俗称`掉帧`。那么原先`GPU`处理好的数据只能由下一帧`VSync`来显示，造成界面的卡顿。\n\n* 卡顿优化的思路：**尽可能减少CPU、GPU的资源消耗。**按照60FPS的刷帧率，每隔16ms就会有一次`VSync`信号，我们只要保证在这个时间段内完成数据的计算，那么卡顿就不会发生。\n\n# 卡顿优化 —— CPU\n\n* 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用`CALayer`取代`UIView`\n\n* 不要频繁地调用`UIView`的相关属性，比如`frame`、`bounds`、`transform`等属性，尽量减少不必要的修改\n\n* 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性\n\n* `Autolayout`会比直接设置`frame`消耗更多的`CPU`资源\n\n* 图片的`size`最好刚好跟`UIImageView`的`size`保持一致\n\n* 控制一下线程的最大`并发数量`\n\n* 尽量把耗时的操作放到`子线程`，例如：\n文本尺寸计算\n```objc\n[@\"text\" boundingRectWithSize:CGSizeMake(100, MAXFLOAT) \noptions:NSStringDrawingUsesLineFragmentOrigin \nattributes:nil context:nil];\n```\n文本绘制：\n```objc\n    [@\"text\" drawWithRect:CGRectMake(0, 0, 100, 100) \n    options:NSStringDrawingUsesLineFragmentOrigin \n    attributes:nil context:nil];\n```\n图片处理（解码、绘制）:\n```objc\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        // 获取CGImage\n        CGImageRef cgImage = [UIImage imageNamed:@\"timg\"].CGImage;\n\n        // alphaInfo\n        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) & kCGBitmapAlphaInfoMask;\n        BOOL hasAlpha = NO;\n        if (alphaInfo == kCGImageAlphaPremultipliedLast ||\n            alphaInfo == kCGImageAlphaPremultipliedFirst ||\n            alphaInfo == kCGImageAlphaLast ||\n            alphaInfo == kCGImageAlphaFirst) {\n            hasAlpha = YES;\n        }\n\n        // bitmapInfo\n        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n\n        // size\n        size_t width = CGImageGetWidth(cgImage);\n        size_t height = CGImageGetHeight(cgImage);\n\n        // context\n        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);\n\n        // draw\n        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage);\n\n        // get CGImage\n        cgImage = CGBitmapContextCreateImage(context);\n\n        // into UIImage\n        UIImage *newImage = [UIImage imageWithCGImage:cgImage];\n\n        // release\n        CGContextRelease(context);\n        CGImageRelease(cgImage);\n\n        // back to the main thread\n        dispatch_async(dispatch_get_main_queue(), ^{\n            self.imageView.image = newImage;\n        });\n    });\n```\n\n# 卡顿优化 —— GPU\n\n* 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示\n\n* GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸\n\n* 尽量减少视图数量和层次\n\n* 减少透明的视图（alpha\\<1），不透明的就设置opaque为YES\n\n* 尽量避免出现离屏渲染\n那么，什么是离屏渲染呢？\n\n# 离屏渲染\n### 概念\n在OpenGL中，GPU有2种渲染方式\n* `On-Screen Rendering`：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作\n* `Off-Screen Rendering`：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作\n\n### 离屏渲染消耗性能的原因\n* 需要创建新的缓冲区\n* 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕\n\n### 哪些操作会触发离屏渲染？\n* 光栅化：\n```objc\nlayer.shouldRasterize = YES\n```\n\n* 遮罩：\n```objc\nlayer.mask\n```\n\n* 圆角，同时设置以下两个变量的值：\n```objc\nlayer.masksToBounds = YES;\nlayer.cornerRadius > 0;\n```\n**考虑通过`CoreGraphics`绘制裁剪圆角，或者叫美工提供圆角图片**\n\n* 阴影：\n```objc\nlayer.shadowXXX\n```\n\n**如果设置了`layer.shadowPath`就不会产生离屏渲染**\n\n# 卡顿的检测\n\n我们平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作，可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的：\n（监测从结束休眠处理source1，到开始休眠处理source0所用的时间）\n","tags":["性能优化"],"categories":["iOS开发"]},{"title":"Objective-C底层原理（五）—— Category","url":"%2F2017%2F01%2F05%2FOC-05-Category%2F","content":"\n<Excerpt in index | 首页摘要>\nCategory的实现原理是什么？\nCategory和class extension有什么区别？\nCategory中的load和initialize方法怎么使用？\nCategory能否添加成员变量？\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# Category","tags":["底层原理"],"categories":["iOS开发"]},{"title":"Objective-C底层原理（四）—— KVC","url":"%2F2017%2F01%2F04%2FOC-04-KVC%2F","content":"\n<Excerpt in index | 首页摘要>\n什么是KVC？\nKVC底层是如何实现的？\n通过KVC修改属性会不会触发KVO？\nKVC的API实现的原理是什么？\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n\n\n\n\n","tags":["底层原理"],"categories":["iOS开发"]},{"title":"Objective-C底层原理（三）—— KVO","url":"%2F2017%2F01%2F03%2FOC-03-KVO%2F","content":"\n<Excerpt in index | 首页摘要>\n\tKVO底层是如何实现的？\n\t如何手动触发KVO？\n\t被KVO监听了的对象发生了什么变化？\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 序言\nKVO，又被成为键值监听，即被监听的键的值发生改变时，做出一系列的响应。\n\n## KVO代码\n\n\n\n\n","tags":["底层原理"],"categories":["iOS开发"]},{"title":"Objective-C底层原理（二）—— OC对象的种类","url":"%2F2017%2F01%2F02%2FOC-02-OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A7%8D%E7%B1%BB%2F","content":"\n<Excerpt in index | 首页摘要>\nObjective-C中的对象共可以分为三种：\n    instance对象（实例对象）\n    class对象（类对象）\n    meta-class对象（元类对象）\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## instance对象\n### 定义：\n通过类`alloc`出来的对象，每次调用`alloc`方法都会产生新的instance对象。\n### 对象内存中存储的信息：\n`instance`对象在内存中存储的信息包括：\n1. `isa`指针\n2. 其它的成员变量\n\n## Class对象\n### 定义：\n先看一组OC代码：\n```objc\n        NSObject *objc = [[NSObject alloc]init];\n        Class obj1 = [objc class];\n        Class obj2 = [NSObject class];\n        Class obj3 = object_getClass(objc);\n```\n其中obj1、obj2、obj3它们都是`Class`类型的对象\n，都是`NSObject`的类对象。\n### 对象内存中存储的信息：\nclass对象在内存中存储的信息主要包括：\n1. `isa`指针；\n2. `superClass`指针；\n3. 类的属性信息(`property`)；\n4. 类的对象方法信息(`instance method`)；\n5. 类的协议信息(`protocol`)；\n6. 类的成员变量信息(`ivar`)；\n    * 注意：这里不包含类方法信息(`class method`)，那么类方法存在了什么地方呢？\n    \n## meta-class对象\n### 定义：\n什么是元类对象？我们看下面一行代码：\n```objc\n        Class metaClassObj = object_getClass([NSObject class]);\n```\n`metaClassObj`是我们通过运行时获取的`NSObject`类对象的类对象，其本质上依然是一个类对象。那么这个`metaClassObj`就是`NSObject`的元类对象(`meta-class`)，并且每个类在内存中有且只有一个元类对象。\n\n### 对象内存中存储的信息：\n`meta-class`和`Class`的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括：\n1. `isa`指针\n2. `superclass`指针\n3. 类的类方法信息(`class method`)\n4. ...\n\n## 比较获取类对象的方法\n \n##### `Class objc_getClass(const char *aClassName)`\n\n 1> 传入字符串类名\n 2> 返回对应的类对象\n \n##### `Class object_getClass(id obj)`\n \n 1> 传入的obj可能是instance对象、class对象、meta-class对象\n 2> 返回值\n a) 如果是instance对象，返回class对象\n b) 如果是class对象，返回meta-class对象\n c) 如果是meta-class对象，返回NSObject（基类）的meta-class对象\n \n##### `- (Class)class、+ (Class)class`\n返回值就是类对象\n```objc \n - (Class) {\n     return self->isa;\n }\n ```\n ```objc\n + (Class) {\n     return self;\n }\n ```\n## 三种对象之间的关系（方法调用原理）\ninstance的isa指向class\n\nclass的isa指向meta-class\n\nmeta-class的isa指向基类的meta-class\n\nclass的superclass指向父类的class\n如果没有父类，superclass指针为nil\n\nmeta-class的superclass指向父类的meta-class\n基类的meta-class的superclass指向基类的class\n\ninstance调用对象方法的轨迹\nisa找到class，方法不存在，就通过superclass找父类\n\nclass调用类方法的轨迹\nisa找meta-class，方法不存在，就通过superclass找父类\n\n如下图所示：\n![](http://peqakd06c.bkt.clouddn.com/15364882268573.jpg)\n\n\n\n\n","tags":["底层原理"],"categories":["iOS开发"]},{"title":"Objective-C底层原理（一）—— 类和实例对象的本质","url":"%2F2017%2F01%2F01%2FOC-01-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F","content":"<Excerpt in index | 首页摘要>\n一个NSObject对象占用多少内存？\n创建一个实例对象至少要分配多少内存？\n对象的isa指针指向哪里？\n内存又是如何分配的，对象又是如何产生的？\nOC对象分为几类？\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 序言\n我们平时写OC代码，写的基本也都得心应手。\n比如创建一个对象，\n\n``` objc\nNSObject *obj = [[NSObject alloc]init];\n```\n那么这个obj占用多少内存，内存又是如何分配的，对象又是如何产生的？\n\n## Objective-C 类的本质\n\nOC代码的底层都是` C/C++` 实现的,所以OC的面向对象都是基于`C/C++`的数据结构来是实现的，那么现在思考一个问题，OC的类和对象是基于`C/C++`的什么`数据结构`实现的？\n\n现在我们打开Xcode，创建一个Command line项目，我们在`main.m`文件中写入以下代码：\n```objc\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSObject *objc = [[NSObject alloc]init];\n    }\n    return 0;\n}\n```\n下面我们找到`main.m`所在的文件目录，运行`Terminal`,并执行以下命令,将`main.m`文件重写成更底层的`C/C++`代码\n#### 不指定架构重写\n```bash\n$ clang -rewrite-objc main.m -o main.cpp\n```\n由于我们现在大都是在64位的平台进行开发，或者\n#### 直接指定arm64架构重写\n```bash\n$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp\n```\n这样输出的文件会比不指定架构时要小很多。\n这里我选择了指定`arm64`架构命令，执行完毕，我们会在原来的文件目录下看到`main.cpp`文件，打开这个文件，并在`7158行`找到如下代码\n```Objc\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n如果我们不将代码转成`C/C++`底层的代码，我们直接通过代码跳转的方式去看NSObject的实现，我们会看到如下代码\n```Objc\n@interface NSObject <NSObject> {\n    Class isa;\n}\n```\n类似的结构，同样的的实例，它们都有且仅有一个`Class`类型的`isa`,这样我们可以从侧面证明，这个结构体就是我们要找的`NSObject`类的底层实现。通过这个一系列的操作，我们发现，`Objective-C`类的底层数据结构其实就是`C/C++`的结构体。\n\n追根溯源，我们继续点击这个`Class`跳转到`Class`定义的地方。\n我们能看到如下代码：\n```objc\ntypedef struct objc_class *Class;\n```\n原来`Class`是一个指向结构体的指针，那么这个对象占用多少内存呢？\n\n## Objective-C 对象的本质\n我们知道，一个指针在`64-bit`系统下占用8个字节的内存，但事实上系统为这个对象仅仅分配了8个字节的内存吗？我们用如下的代码来证实一下：\n\n```objc\n#import <Foundation/Foundation.h>\n#import <objc/runtime.h>\n#import <malloc/malloc.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSObject *objc = [[NSObject alloc]init];\n        //  获得NSObject类的实例对象的大小（runtime方法）\n        NSLog(@\"%zd\", class_getInstanceSize([NSObject class]));\n        //  获得objc指针所指向的内存大小（malloc方法）\n        NSLog(@\"%zd\", malloc_size((__bridge const void *)(objc)));\n    }\n    return 0;\n}\n```\n点击运行，这时我们看到输出结果如下：\n```\n2018-09-02 14:39:25.626472+0800 Main[26564:3507573] 8\n2018-09-02 14:39:25.627123+0800 Main[26564:3507573] 16\nProgram ended with exit code: 0\n```\n一个输出8，一个输出16。也就是说NSObject类的实例对象的大小并不是objc对象所占用的内存大小，这到底是怎么回事呢？\n基于Apple目前开源的源码，我们打开[苹果源码](https://opensource.apple.com/tarballs/objc4)，并下载[objc4-723.tar.gz](https://opensource.apple.com/tarballs/objc4/objc4-723.tar.gz)解压后打开这个项目。\n\n#### class_getInstanceSize\n我们直接全局搜索`class_getInstanceSize`，然后找到`objc-class.mm`文件中的对应的实现代码：\n```objc\nsize_t class_getInstanceSize(Class cls)\n{\n    if (!cls) return 0;\n    return cls->alignedInstanceSize();\n}\n```\n继续查看`alignedInstanceSize()`方法的实现：\n```objc\n   // Class's ivar size rounded up to a pointer-size boundary.\n    uint32_t alignedInstanceSize() {\n        return word_align(unalignedInstanceSize());\n    }\n```\n这里有一句注释，翻译成中文就是`类的实例对象的成员变量所占用的内存大小`，这个值就是`8`。\n\n#### allocWithZone\n我们继续全局搜索`allocWithZone`，然后找到`NSObject.mm`文件中定义的这个函数，\n```c\nid\n_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)\n```\n并且函数内部找到以下这句代码调用，\n```objc\nobj = class_createInstance(cls, 0);\n```\n并跳转到`class_createInstance`函数的实现，我们可以看到如下的代码\n```c\nid \nclass_createInstance(Class cls, size_t extraBytes)\n{\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n}\n```\n我们继续跳转到`_class_createInstanceFromZone`函数的实现，在这个函数的实现内部，我们发现了有以下代码\n```c\n    if (!zone  &&  fast) {\n        obj = (id)calloc(1, size);\n        if (!obj) return nil;\n        obj->initInstanceIsa(cls, hasCxxDtor);\n    } \n```\n这里的obj在创建的时候，调用了一个`calloc`方法，并将`size`作为参数传了进去，这里的`size`哪里来的呢？我们跳转到`size`定义的地方，`size_t`类型的`size`变量通过如下代码创建的：\n```objc\nsize_t size = cls->instanceSize(extraBytes);\n```\n我们再去看`instanceSize()`函数的实现：\n```c\n    size_t instanceSize(size_t extraBytes) {\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n我们又一次看到了`alignedInstanceSize()`这个函数，我们上面说过，`NSObject`对象在调用这个函数时，分配的内存的大小时8，而`extraBytes`的大小为0。所以这个size就是8；那么通过下面的代码，我们将初始化的对象分配了16个字节的大小。这行代码的意思就是，凡是内存小于16个字节的对象，全部强制分配给16个字节。\n\n也就是说，这个对象在创建的时候，系统给其分配了16个字节的存储空间，但是其成员变量只占用了8个字节。\n\n现在再提出一个问题，看以下代码，创建一个`Student`的类的实例，问这个实例，系统分配多少内存？\n```objc\n@interface Student : NSObject \n{\n    int _age;\n    int _height;\n}\n@end\n```\n\n```c\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Student *stu = [[Student alloc]init];\n    }\n    return 0;\n}\n```\n\n我们同样用指定`arm64`架构的方式对文件进行重写，然后找到`Student`类对应的代码：\n```objc\nstruct Student_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n\tint _age;\n\tint _height;\n};\n```\n并且找到`NSObject_IMPL`定义的地方\n```objc\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n其实相当于这个`Student`类的底层实现是这个样子的:\n```objc\nstruct Student_IMPL {\n   Class isa; // 8个字节\n\tint _age; // 4个字节\n\tint _height; // 4个字节\n};\n```\n其中`_age`和`_height`都是占用四个字节的内存，这样，`Student_IMPL`这个结构体就会占用16个字节的内存。可以使用`malloc_size()`函数来证实一下。\n其实这里也用到一个`内存对齐`的一个概念，意思就是说结构体内成员按自身按自身长度自对齐，结构体的大小必须是最大成员大小的倍数，在这个结构体中，成员大小最小是16个字节，那么16其大小也必须是16的倍数。事实上，系统给这个结构体也只分配了16个字节的存储空间。\n\n\n## 总结\n1、OC中类的本质其实就是一个结构体\n2、指定`arm64`架构重写OC文件的命令\n```bash\n$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp\n```\n3、一个`NSObject`对象占用8个字节的存储空间，但是系统会为该对象分配16个字节的存储空间\n4、内存对齐\n\n","tags":["底层原理"],"categories":["iOS开发"]},{"title":"Markdown 语法和 MWeb 写作使用说明","url":"%2F2016%2F02%2F02%2Ftool-02-%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E5%86%99%E5%8D%9A%E5%AE%A2%2F","content":"\n<Excerpt in index | 首页摘要>\nMarkdown 的目標是實現「易讀易寫」。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# Markdown 语法和 MWeb 写作使用说明\n\n## Markdown 的设计哲学\n\n> Markdown 的目標是實現「易讀易寫」。\n> 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。\n> Markdown 的語法有個主要的目的：用來作為一種網路內容的*寫作*用語言。\n\n<!-- more -->\n\n## 本文约定\n\n如果有写 `效果如下：`， 在 MWeb 编辑状态下只有用 `CMD + R` 预览才可以看效果。\n\n## 标题\n\nMarkdown 语法：\n\n```\n# 第一级标题 `<h1>` \n## 第二级标题 `<h2>` \n###### 第六级标题 `<h6>` \n```\n\n效果如下：\n\n# 第一级标题 `<h1>` \n## 第二级标题 `<h2>` \n###### 第六级标题 `<h6>` \n\n\n\n## 强调\n\nMarkdown 语法：\n\n```\n*这些文字会生成`<em>`*\n_这些文字会生成`<u>`_\n\n**这些文字会生成`<strong>`**\n__这些文字会生成`<strong>`__\n```\n\n在 MWeb 中的快捷键为： `CMD + U`、`CMD + I`、`CMD + B`\n效果如下：\n\n*这些文字会生成`<em>`*\n_这些文字会生成`<u>`_\n\n**这些文字会生成`<strong>`**\n__这些文字会生成`<strong>`__\n\n## 换行\n\n四个及以上空格加回车。\n如果不想打这么多空格，只要回车就为换行，请勾选：`Preferences` - `Themes` - `Translate newlines to <br> tags`\n\n## 列表\n\n### 无序列表\n\nMarkdown 语法：\n\n```\n* 项目一 无序列表 `* + 空格键`\n* 项目二\n\t* 项目二的子项目一 无序列表 `* + TAB + 空格键`\n\t* 项目二的子项目二\n```\n\n在 MWeb 中的快捷键为： `Option + U`\n效果如下：\n\n* 项目一 无序列表 `* + 空格键`\n* 项目二\n\t* 项目二的子项目一 无序列表 `* + TAB + 空格键`\n\t* 项目二的子项目二\n\n### 有序列表\n\nMarkdown 语法：\n\n```\n1. 项目一 有序列表 `数字 + . + 空格键`\n2. 项目二 \n3. 项目三\n\t1. 项目三的子项目一 有序列表 `数字 + . + TAB + 空格键`\n\t2. 项目三的子项目二\n```\n\n效果如下：\n\n1. 项目一 有序列表 `数字 + . + 空格键`\n2. 项目二 \n3. 项目三\n\t1. 项目三的子项目一 有序列表 `数字 + . + TAB + 空格键`\n\t2. 项目三的子项目二\n\n### 任务列表（Task lists）\n\nMarkdown 语法：\n\n```\n- [ ] 任务一 未做任务 `- + 空格 + [ ]`\n- [x] 任务二 已做任务 `- + 空格 + [x]`\n```\n\n效果如下：\n\n- [ ] 任务一 未做任务 `- + 空格 + [ ]`\n- [x] 任务二 已做任务 `- + 空格 + [x]`\n\n## 图片\n\nMarkdown 语法：\n\n```\n![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)\n格式: ![Alt Text](url)\n```\n\n`Control + Shift + I` 可插入Markdown语法。\n如果是 MWeb 的文档库中的文档，还可以用拖放图片、`CMD + V` 粘贴、`CMD + Option + I` 导入这三种方式来增加图片。\n效果如下：\n\n![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)\n\n## 链接\n\nMarkdown 语法：\n\n```\nemail <example@example.com>\n[GitHub](http://github.com)\n自动生成连接  <http://www.github.com/>\n```\n\n`Control + Shift + L` 可插入Markdown语法。\n如果是 MWeb 的文档库中的文档，拖放或`CMD + Option + I` 导入非图片时，会生成连接。\n效果如下：\n\nEmail 连接： <example@example.com>\n[连接标题Github网站](http://github.com)\n自动生成连接像： <http://www.github.com/> 这样\n\n## 区块引用\n\nMarkdown 语法：\n\n```\n某某说:\n> 第一行引用\n> 第二行费用文字\n```\n\n`CMD + Shift + B` 可插入Markdown语法。\n效果如下：\n\n某某说:\n> 第一行引用\n> 第二行费用文字\n\n## 行内代码\n\nMarkdown 语法：\n\n```\n像这样即可：`<addr>` `code`\n```\n\n`CMD + K` 可插入Markdown语法。\n效果如下：\n\n像这样即可：`<addr>` `code`\n\n## 多行或者一段代码\n\nMarkdown 语法：\n\n\t```js\n\tfunction fancyAlert(arg) {\n\t  if(arg) {\n\t    $.facebox({div:'#foo'})\n\t  }\n\n\t}\n\t```\n\n`CMD + Shift + K` 可插入Markdown语法。\n效果如下：\n\n```js\nfunction fancyAlert(arg) {\n\tif(arg) {\n\t\t$.facebox({div:'#foo'})\n\t}\n\t\n}\n```\n\n## 顺序图或流程图\n\nMarkdown 语法：\n\n\t```sequence\n\t张三->李四: 嘿，小四儿, 写博客了没?\n\tNote right of 李四: 李四愣了一下，说：\n\t李四-->张三: 忙得吐血，哪有时间写。\n\t```\n\n\t```flow\n\tst=>start: 开始\n\te=>end: 结束\n\top=>operation: 我的操作\n\tcond=>condition: 确认？\n\n\tst->op->cond\n\tcond(yes)->e\n\tcond(no)->op\n\t```\n\n效果如下（ `Preferences` - `Themes` - `Enable sequence & flow chart` 才会看到效果 ）：\n\n```sequence\n张三->李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四-->张三: 忙得吐血，哪有时间写。\n```\n\n```flow\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n更多请参考：<http://bramp.github.io/js-sequence-diagrams/>, <http://adrai.github.io/flowchart.js/>\n\n## 表格\n\nMarkdown 语法：\n\n```\n第一格表头 | 第二格表头\n--------- | -------------\n内容单元格 第一列第一格 | 内容单元格第二列第一格\n内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格\n```\n\n效果如下：\n\n第一格表头 | 第二格表头\n--------- | -------------\n内容单元格 第一列第一格 | 内容单元格第二列第一格\n内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格\n\n\n## 删除线\n\nMarkdown 语法：\n\n\t加删除线像这样用： ~~删除这些~~\n\n效果如下：\n\n加删除线像这样用： ~~删除这些~~\n\n## 分隔线\n\n以下三种方式都可以生成分隔线：\n\n\t***\n\n\t*****\n\n\t- - -\n\n效果如下：\n\n***\n\n*****\n\n- - -\n\n\n## MathJax\n\nMarkdown 语法：\n\n\n```\n块级公式：\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n\\\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =\n1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}\n{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\\\]\n\n行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n```\n\n效果如下（`Preferences` - `Themes` - `Enable MathJax` 才会看到效果）：\n\n块级公式：\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n\\\\[ \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =\n1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}\n{1+\\frac{e^{-8\\pi}} {1+\\ldots} } } } \\\\]\n\n\n行内公式： $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$\n\n\n## 脚注（Footnote）\n\nMarkdown 语法：\n\n```\n这是一个脚注：[^sample_footnote]\n```\n\n效果如下：\n\n这是一个脚注：[^sample_footnote]\n\n[^sample_footnote]: 这里是脚注信息\n\n\n## 注释和阅读更多\n\n<!-- comment -->\n<!-- more -->\nActions->Insert Read More Comment *或者* `Command + .`\n**注** 阅读更多的功能只用在生成网站或博客时。\n\n## TOC\n\nMarkdown 语法：\n\n```\n[TOC]\n```\n\n效果如下：\n\n[TOC]\n\n","tags":["Markdown"],"categories":["实用工具"]},{"title":"MWeb介绍","url":"%2F2016%2F02%2F01%2Ftool-01-MWeb%E4%BB%8B%E7%BB%8D%2F","content":"\n<Excerpt in index | 首页摘要>\nMWeb简介\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# MWeb - 专业的 Markdown 写作、记笔记、静态博客生成软件\n\n## 专业的 Markdown 写作支持\n\n* 极简 UI、Dark Mode、漂亮的 Markdown 语法高亮、列表缩进优化，提供 5 种主题选择。\n* 除了支持基本的 Markdown 语法外，还支持大量 Markdown 扩展语法：Table、TOC、MathJax、Fenced code block、任务列表（Task lists）、顺序图和流程图、Footnote 等。\n* 支持 Typewriter Scrolling（打机滚动模式）`View` - `Typewriter Scrolling`。\n* 支持发布和**更新**到：Wordrpess 博客、支持 Metaweblog API 的博客服务、Wordpress.com、Evernote 和印象笔记、Blogger、Tumblr。请在 `Preferences` - `Publishing` 增加发布服务，然后点击软件右上角的分享按钮即可看到所增加的发布服务。\n* 支持即时预览并提供 6 种预览主题，其中二种和静态博客主题相对应，也就是说您在写博客时可以即时预览大概效果！所有主题效果都支持导出为 HTML、PDF。快捷键 `CMD + R` 或 `CMD + 4` 打开即时预览窗口。\n* 编辑器和实时预览都支持大纲视图，长文档时跳转非常方便。\n\n## 设计为两种模式\n\n* 外部文档模式：用于新建、打开和编辑外部 Markdown 文档。也支持引入外部文件夹到 MWeb 中管理。\n* 文档库模式：用分类树管理文档，可以把文档设为多个分类，用于记笔记和静态网站生成。\n\n`CMD + E` 或使用菜单 `View` - `Open External` 可打开外部文档模式。\n\n`CMD + L` 或使用菜单 `View` - `Open Library` 可打开文档库。\n\n文档库模式和外部模式都支持**全文搜寻（Full Text Search）**，都可以用拖放或粘贴插入图片并直接显示。`CMD + V` 粘贴为JPG格式，`CMD + Shift + V` 粘贴为PNG透明格式。\n\n外部模式引入 Octpress、Jekyll 等静态博客的文件夹后也支持拖放或粘贴插入图片和实时预览，详细请参考：[引入文件夹到 MWeb 中管理，支持 Octpress、Jekyll 等静态博客拖拽插入图片和实时预览](http://zh.mweb.im/mweb-1.4-add-floder-octpress-support.html)\n\n## 文档库模式用于记笔记\n\n文档库模式使用分类树组织和管理文档，支持拖放或粘贴插入图片并直接显示，插入非图片则会生成连结。\n支持把 Markdown 或文本文档导入到文档库，也支持把整个分类或者文档（可选多个）导出为 HTML、PDF、Markdown。\n\n更详细的信息请看：[MWeb 文档库模式详细说明](http://zh.mweb.im/mweb-document-library.html)\n\n\n## 文档库模式用于静态博客生成\n\n一键把分类生成静态博客，目前可选二个主题，支持自定主题。只要填入 Disqus、多说提供的代码即可以为博客增加评论功能。可勾选让网站支持 MathJax 和顺序图、流程图。\n\n更详细的信息请看：[MWeb 生成静态博客详细说明](http://zh.mweb.im/mweb-static-blog-generator.html)、[静态博客功能增强](http://zh.mweb.im/mweb-1.4-static-blog-extension.html)\n\n\n","tags":["Markdown"],"categories":["实用工具"]},{"title":"静心阅读","url":"%2F2015%2F01%2F01%2F%E9%9D%99%E5%BF%83%E9%98%85%E8%AF%BB%2F","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\n欢迎大家来看我的技术博客，本人从事iOS开发。\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## 测试用的博客\n\n","tags":["随笔"],"categories":["静心阅读"]}]